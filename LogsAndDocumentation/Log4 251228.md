# GDMS micro – Development Log & Architecture Notes  
**Author:** Alexander Sousa  
**Date:** 2025  
**Platform:** Arduino micro–class (ATmega328P, Elegoo nano clone)  
**Display:** SSD1306 128×64 OLED (I²C) using U8x8 text mode  

---

Important Note -- Project pivotted from GDMS pocket to GDMS micro to create something that could exist on an elegoo nano, a clone of an outdated verison of the arduino nano independent of SD cards. a standalone device with no adaptive menus or user-addable content. 


## 1. Project Goal (High-Level)

GDMS micro is a **single-purpose, table-facing Dungeon Master aid** designed to provide:

- Instant inspiration  
- Fast multi-roll results (NPCs, rooms, encounters)  
- A tactile, distraction-free alternative to laptops and phones  

Design philosophy:
- **Finite, intentional, offline**
- No search, no editing, no scrolling feeds
- Curated content over infinite content
- Physical buttons + simple screen = ritual tool, not software suite

---

## 2. Hardware Constraints (Critical)

**MCU:** ATmega328P (Elegoo micro clone)  
- Flash: ~30 KB usable  
- SRAM: 2 KB total  

These constraints strongly shape all design decisions.

Key implications:
- Dynamic memory must be tightly controlled
- Avoid heap usage (`String`, dynamic allocation)
- All large/static text must live in flash (PROGMEM)
- UI complexity must be minimal

---

## 3. Major Technical Decisions Made

### 3.1 Switched from U8g2 to U8x8

**Reason:**  
U8g2 font rendering consumed excessive flash memory.

**Outcome:**
- Program flash usage dropped from ~75% to ~36%
- SRAM usage dropped to ~38%
- Freed ~19 KB flash for future content (tables, generators)

**Tradeoff:**
- Text-only UI (16 columns × 8 rows)
- No proportional fonts
- 2×2 text scaling available via `draw2x2String()`

This aligns well with the Shadowdark / minimalist aesthetic.

---

### 3.2 Fixed Buffers + PROGMEM Everywhere

**Key pattern adopted:**
```cpp
char buffer[16];   // fixed-size RAM buffer
```

- All tables and strings stored in PROGMEM
- Only the selected result is copied into RAM
- Prevents heap fragmentation and crashes

**Rule established:**  
RAM holds *only what is currently visible or being processed*.

---

## 4. System Architecture Introduced

### 4.1 Applet-Based UI Model

The system now uses a **two-layer state machine**:

#### UI Mode
```cpp
enum UiMode { MODE_HOME, MODE_APPLET };
```

- `MODE_HOME`: select which applet to use
- `MODE_APPLET`: interact with the selected applet

#### Applet Selection
```cpp
enum Applet { APP_DICE, APP_NAMES, APP_ROOM };
```

- Applets are **features**, not data
- Applet list is intentionally small and curated
- SD-card dynamism (future) belongs *inside* applets, not at the top level

---

### 4.2 Button Semantics by Mode

Same physical buttons, different meaning depending on context:

#### HOME Mode
- `<` / `>` : cycle applets
- `X` : enter selected applet

#### APPLET Mode
- Applet-specific behavior
- **Exit gesture:** hold `<` + `>` simultaneously to return HOME

---

### 4.3 Draw Responsibility Separation

Drawing is now explicitly separated:

```cpp
void drawHome();
void drawDice();
void drawNames();
void drawRoom();
void drawUi();
```

- Drawing functions never change state
- Button logic never draws directly
- `drawUi()` is the only rendering entry point

---

## 5. Applets Implemented

### 5.1 Dice Applet
- Cycles through D4 → D100
- X rolls the selected die
- Displays result in 2×2 text
- Buzzer pitch mapped to die size
- LED pop feedback

Status: **Complete and stable**

---

### 5.2 Names Applet
- Single flat list of names
- X picks a random name
- Names stored in PROGMEM
- Selected name copied into fixed buffer

Status: **Placeholder, expandable**

---

### 5.3 Room Applet
Chained generator producing:
- Size
- Feature
- Threat
- Exit

Status: **Flagship proof-of-concept**

---

## 6. Splash Screen
- Displays on startup only
- 2-second delay
- Implemented in `setup()`

---

## 7. Memory Snapshot

```
Sketch uses 11,346 bytes (36%) of program storage.
Global variables use 794 bytes (38%) of dynamic memory.
```

---

## 8. Lessons Learned

- State machines simplify UI scaling
- Fonts are often the largest flash cost
- Fixed buffers prevent instability
- Compression of effort beats feature bloat

---

## 9. Future Work
- Names applet: ancestry selection
- SD-backed table browsing
- NPC chained generator
- Optional RP2040 migration

---

## 10. Design Guardrails

- No free text entry
- No search
- No rules enforcement
- No persistent campaign state

**GDMS micro suggests. The DM decides.**
