/*
  POC_V04_SPI128x128_SH1107.ino

  Rewrite of POC_V04 for:
  - Feather RP2040 Adalogger
  - 1.5" SH1107 128x128 OLED (SPI) via U8g2
  - SD card via SdFat on SPI1 (OLED uses SW SPI to avoid conflicts)

  Based on:
  - POC_V04 structure/state machine/UI logic  :contentReference[oaicite:3]{index=3}
  - Log8 pin map + SH1107 offset note        :contentReference[oaicite:4]{index=4}
*/

#include <Arduino.h>

#include <U8g2lib.h>
#include <SPI.h>
#include <SdFat.h>

// =================== PINS (from Log8 known-good) ===================
// Buttons (active-low, INPUT_PULLUP). Wired pin -> GND
// Up=A2, Down=A3, A=A1, B=A0
enum BtnId : uint8_t { BTN_A = 0, BTN_B = 1, BTN_UP = 2, BTN_DOWN = 3 };
const uint8_t BTN_PINS[4]  = { A1, A0, A2, A3 };
const char*   BTN_NAMES[4] = { "A(A1)", "B(A0)", "UP(A2)", "DN(A3)" };

// Buzzer signal on D5 (passive buzzer module)
const uint8_t BUZZER_PIN = 5;

// External LED on D24 (anode via resistor -> D24, cathode -> GND)
const uint8_t LED_PIN = 24;

// OLED (software SPI) pin mapping per Log8:
// SCL/CLK=D13, SDA/DATA=D12, DC=D11, CS=D10, RST=D9
const uint8_t OLED_CLK = 13;
const uint8_t OLED_DAT = 12;
const uint8_t OLED_DC  = 11;
const uint8_t OLED_CS  = 10;
const uint8_t OLED_RST = 9;

// =================== OLED (U8g2) ===================
// Page-buffer constructor (lighter RAM). You can switch to _F_ later if desired.
// NOTE: If you see a 32px wrap/shift, apply the U8g2 SH1107 x_offset patch described in Log8.
U8G2_SH1107_128X128_1_4W_SW_SPI u8g2(
  U8G2_R2,
  /* clock=*/ OLED_CLK,
  /* data=*/  OLED_DAT,
  /* cs=*/    OLED_CS,
  /* dc=*/    OLED_DC,
  /* reset=*/ OLED_RST
);

// =================== LED DIM ===================
const uint8_t LED_DIM = 2; // 0–255

// =================== BUTTONS (debounce + edge detect) ===================
bool wasPressed[4] = {false, false, false, false};
uint32_t lastPressMs[4] = {0, 0, 0, 0};
const uint16_t DEBOUNCE_MS = 40;

// =================== NON-BLOCKING LED BLINK ===================
bool ledBlinkOn = false;
uint32_t ledOffMs = 0;

// =================== NON-BLOCKING BUZZER ===================
bool buzOn = false;
uint32_t buzOffMs = 0;

void buzzerStart(uint16_t freq, uint16_t durMs) {
  tone(BUZZER_PIN, freq);
  buzOn = true;
  buzOffMs = millis() + durMs;
}
void buzzerUpdate(uint32_t now) {
  if (buzOn && (int32_t)(now - buzOffMs) >= 0) {
    noTone(BUZZER_PIN);
    buzOn = false;
  }
}

// =================== SD (Adafruit Feather RP2040 Adalogger) ===================
#define SD_CS_PIN 23
SdFat SD;
SdSpiConfig sdConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(16), &SPI1);

// =================== APP STATE ===================
static const uint8_t MAX_CATS = 40;
String categories[MAX_CATS];
uint8_t catCount = 0;

int16_t cursor = 0;     // which category is selected
int16_t scrollTop = 0;  // first visible row

static const uint8_t MAX_FILES = 60;
String files[MAX_FILES];
uint8_t fileCount = 0;

int16_t fileCursor = 0;
int16_t fileScrollTop = 0;

enum UiMode : uint8_t { MODE_CATS = 0, MODE_FILES = 1, MODE_TABLE = 2 };
UiMode mode = MODE_CATS;

String selectedCat;
String selectedFile;

String currentEntry;     // the chosen CSV row (raw line)
uint16_t rollCount = 0;  // how many rerolls in this table view
int16_t tableScrollLine = 0; // which wrapped line to start drawing from

// =================== OLED THROTTLE POLICY ===================
uint32_t lastInputMs = 0;
uint32_t lastOledMs = 0;
const uint16_t OLED_PERIOD_MS = 90;
const uint16_t OLED_IDLE_AFTER_MS = 0;

// ---------- helpers ----------
static inline String stripCsvExt(const String& s) {
  if (s.length() >= 4) {
    String tail = s.substring(s.length() - 4);
    tail.toLowerCase();
    if (tail == ".csv") return s.substring(0, s.length() - 4);
  }
  return s;
}

static inline bool endsWithCsv(const String& s) {
  if (s.length() < 4) return false;
  String tail = s.substring(s.length() - 4);
  tail.toLowerCase();
  return tail == ".csv";
}

// Conservative ellipsize by character count (works fine for your mostly-ASCII UI labels)
static inline String ellipsize(const String& s, uint8_t maxChars) {
  if (s.length() <= maxChars) return s;
  if (maxChars <= 3) return s.substring(0, maxChars);
  return s.substring(0, maxChars - 3) + "...";
}

// Count wrapped lines for a string at charsPerLine
static uint16_t countWrappedLines(const String& s, uint8_t charsPerLine) {
  if (charsPerLine == 0) return 0;
  uint16_t lines = 1;
  uint8_t col = 0;

  for (uint16_t i = 0; i < s.length(); i++) {
    char c = s[i];
    if (c == '\n') { lines++; col = 0; continue; }
    col++;
    if (col >= charsPerLine) { lines++; col = 0; }
  }
  return lines;
}

// Simple right-aligned counter "i/n" on header line
static void drawHeader(const String& title, int currentIndexZeroBased = -1, int totalCount = -1) {
  const int W = 128;

  u8g2.setFont(u8g2_font_6x12_tf); // readable, compact
  u8g2.drawStr(0, 12, title.c_str());

  if (totalCount > 0 && currentIndexZeroBased >= 0) {
    int pos = currentIndexZeroBased + 1;
    if (pos < 1) pos = 1;
    if (pos > totalCount) pos = totalCount;

    char buf[16];
    snprintf(buf, sizeof(buf), "%d/%d", pos, totalCount);

    int textW = u8g2.getStrWidth(buf);
    u8g2.drawStr(W - textW, 12, buf);
  }

  // divider line under header
  u8g2.drawHLine(0, 16, 128);
}

// ---------- SD scanning ----------
void scanCategories() {
  catCount = 0;

  if (!SD.exists("/DATA")) {
    Serial.println("No /DATA directory found.");
    return;
  }

  FsFile dataDir = SD.open("/DATA");
  if (!dataDir || !dataDir.isDirectory()) {
    Serial.println("Failed to open /DATA as directory.");
    return;
  }

  FsFile entry;
  while (catCount < MAX_CATS && (entry = dataDir.openNextFile())) {
    if (entry.isDirectory()) {
      char nameBuf[64];
      entry.getName(nameBuf, sizeof(nameBuf));
      if (nameBuf[0] != '.') {
        categories[catCount++] = String(nameBuf);
      }
    }
    entry.close();
  }
  dataDir.close();

  cursor = 0;
  scrollTop = 0;

  Serial.print("Found categories: ");
  Serial.println(catCount);
}

void scanCsvFilesForSelectedCategory() {
  fileCount = 0;
  fileCursor = 0;
  fileScrollTop = 0;

  String path = String("/DATA/") + selectedCat;

  if (!SD.exists(path.c_str())) {
    Serial.print("Folder missing: ");
    Serial.println(path);
    return;
  }

  FsFile dir = SD.open(path.c_str());
  if (!dir || !dir.isDirectory()) {
    Serial.print("Not a directory: ");
    Serial.println(path);
    return;
  }

  FsFile entry;
  while (fileCount < MAX_FILES && (entry = dir.openNextFile())) {
    if (!entry.isDirectory()) {
      char nameBuf[64];
      entry.getName(nameBuf, sizeof(nameBuf));
      String fn = String(nameBuf);
      if (endsWithCsv(fn)) {
        files[fileCount++] = fn;
      }
    }
    entry.close();
  }
  dir.close();

  Serial.print("CSV files in ");
  Serial.print(path);
  Serial.print(": ");
  Serial.println(fileCount);
}

bool pickRandomCsvLine(const String& fullPath, String& outLine) {
  FsFile f = SD.open(fullPath.c_str(), O_RDONLY);
  if (!f) {
    Serial.print("Open failed: ");
    Serial.println(fullPath);
    return false;
  }

  randomSeed(micros());

  const size_t BUF_SZ = 220;
  char buf[BUF_SZ];

  uint32_t seen = 0;
  bool chosen = false;
  outLine = "";

  while (true) {
    int n = f.fgets(buf, (int)BUF_SZ);
    if (n <= 0) break;

    while (n > 0 && (buf[n - 1] == '\n' || buf[n - 1] == '\r')) {
      buf[--n] = '\0';
    }

    if (n == 0) continue;
    if (buf[0] == '#' || (buf[0] == '/' && buf[1] == '/')) continue;

    seen++;
    if (random((long)seen) == 0) {
      outLine = String(buf);
      chosen = true;
    }
  }

  f.close();
  return chosen;
}

// ---------- UI draw ----------
void drawCategories() {
  u8g2.firstPage();
  do {
    drawHeader("GDMS-pocket", cursor, catCount);

    if (catCount == 0) {
      u8g2.drawStr(0, 40, "No folders found.");
      u8g2.drawStr(0, 55, "Need /DATA/<FOLDER>");
      continue;
    }

    // Layout on 128x128:
    // Header line at y=12, divider at y=16.
    // List starts y=30-ish, 12px per row with 6x12 font.
    const int listY0 = 30;
    const int rowH   = 14;
    const int rows   = 6;

    if (cursor < 0) cursor = 0;
    if (cursor >= (int)catCount) cursor = catCount - 1;

    if (cursor < scrollTop) scrollTop = cursor;
    if (cursor >= scrollTop + rows) scrollTop = cursor - rows + 1;

    u8g2.setFont(u8g2_font_6x12_tf);

    for (int r = 0; r < rows; r++) {
      int idx = scrollTop + r;
      if (idx >= (int)catCount) break;

      int y = listY0 + r * rowH;

      String name = categories[idx];
      name = ellipsize(name, 19);

      if (idx == cursor) {
        u8g2.drawStr(0, y, "> ");
        u8g2.drawStr(14, y, name.c_str());
      } else {
        u8g2.drawStr(0, y, "  ");
        u8g2.drawStr(14, y, name.c_str());
      }
    }
  } while (u8g2.nextPage());
}

void drawFiles() {
  u8g2.firstPage();
  do {
    drawHeader(selectedCat, fileCursor, fileCount);

    u8g2.setFont(u8g2_font_6x12_tf);

    if (fileCount == 0) {
      u8g2.drawStr(0, 40, "No .csv files.");
      continue;
    }

    const int listY0 = 30;
    const int rowH   = 14;
    const int rows   = 6;

    if (fileCursor < 0) fileCursor = 0;
    if (fileCursor >= (int)fileCount) fileCursor = fileCount - 1;

    if (fileCursor < fileScrollTop) fileScrollTop = fileCursor;
    if (fileCursor >= fileScrollTop + rows) fileScrollTop = fileCursor - rows + 1;

    for (int r = 0; r < rows; r++) {
      int idx = fileScrollTop + r;
      if (idx >= (int)fileCount) break;

      int y = listY0 + r * rowH;

      String shown = stripCsvExt(files[idx]);
      shown = ellipsize(shown, 19);

      if (idx == fileCursor) {
        u8g2.drawStr(0, y, "> ");
        u8g2.drawStr(14, y, shown.c_str());
      } else {
        u8g2.drawStr(0, y, "  ");
        u8g2.drawStr(14, y, shown.c_str());
      }
    }
  } while (u8g2.nextPage());
}

void drawTable() {
  // Wrapping assumptions for 6x12 font:
  // 128px / ~6px per char ≈ 21 chars
  const uint8_t CHARS_PER_LINE = 21;

  // Text block: start under header divider
  const int y0 = 30;
  const int lineH = 14; // 12px font + a bit of breathing room
  const int maxLinesOnScreen = (128 - y0) / lineH; // ~7 lines

  uint16_t totalLines = countWrappedLines(currentEntry, CHARS_PER_LINE);

  if (tableScrollLine < 0) tableScrollLine = 0;
  int16_t maxScroll = (int16_t)totalLines - (int16_t)maxLinesOnScreen;
  if (maxScroll < 0) maxScroll = 0;
  if (tableScrollLine > maxScroll) tableScrollLine = maxScroll;

  String hdr = stripCsvExt(selectedFile);
  hdr = ellipsize(hdr, 21);

  u8g2.firstPage();
  do {
    // Header: use rollCount as counter (same intent as your POC_V04)
    int cur = (rollCount > 0 ? (int)rollCount - 1 : 0);
    int tot = (rollCount > 0 ? (int)rollCount : 0);
    drawHeader(hdr, cur, tot);

    u8g2.setFont(u8g2_font_6x12_tf);

    if (currentEntry.length() == 0) {
      u8g2.drawStr(0, 40, "No entry read.");
      continue;
    }

    // Render wrapped lines, but only those visible
    int16_t curLine = 0;
    int16_t drawLine = 0;
    uint8_t col = 0;

    // We'll build each visible line into a small char buffer for clean drawStr calls
    // (u8g2 likes whole strings more than per-char writes).
    char lineBuf[CHARS_PER_LINE + 1];
    memset(lineBuf, 0, sizeof(lineBuf));
    uint8_t linePos = 0;

    auto flushLineIfVisible = [&](bool force) {
      if (!force && linePos == 0) return;

      if (curLine >= tableScrollLine && drawLine < maxLinesOnScreen) {
        int y = y0 + drawLine * lineH;
        lineBuf[linePos] = '\0';
        u8g2.drawStr(0, y, lineBuf);
        drawLine++;
      }

      // reset
      memset(lineBuf, 0, sizeof(lineBuf));
      linePos = 0;
    };

    for (uint16_t i = 0; i < currentEntry.length(); i++) {
      char c = currentEntry[i];

      if (c == '\n') {
        flushLineIfVisible(true);
        curLine++;
        col = 0;
        if (drawLine >= maxLinesOnScreen) break;
        continue;
      }

      // wrap
      if (col >= CHARS_PER_LINE) {
        flushLineIfVisible(true);
        curLine++;
        col = 0;
        if (drawLine >= maxLinesOnScreen) break;
      }

      // append char to current line buffer (best-effort; ignore overflow)
      if (linePos < CHARS_PER_LINE) {
        lineBuf[linePos++] = c;
      }

      col++;
    }

    // flush last partial line
    flushLineIfVisible(true);

  } while (u8g2.nextPage());
}

void uiRedraw() {
  if (mode == MODE_CATS) drawCategories();
  else if (mode == MODE_FILES) drawFiles();
  else drawTable();
}

// ---------- input handling ----------
void onButtonPressed(BtnId b) {
  lastInputMs = millis();

  // LED blink
  analogWrite(LED_PIN, LED_DIM);
  ledBlinkOn = true;
  ledOffMs = lastInputMs + 80;

  // button chirp
  uint16_t base = 700;
  uint16_t freq = base + (uint16_t)b * 200;
  buzzerStart(freq, 30);

  if (mode == MODE_CATS) {
    if (b == BTN_UP) cursor--;
    else if (b == BTN_DOWN) cursor++;
    else if (b == BTN_A) {
      if (catCount > 0) {
        selectedCat = categories[cursor];
        scanCsvFilesForSelectedCategory();
        mode = MODE_FILES;
      }
    } else if (b == BTN_B) {
      // no-op at top level
    }
  } else if (mode == MODE_FILES) {
    if (b == BTN_UP) fileCursor--;
    else if (b == BTN_DOWN) fileCursor++;
    else if (b == BTN_A) {
      if (fileCount > 0) {
        selectedFile = files[fileCursor];

        String fullPath = String("/DATA/") + selectedCat + "/" + selectedFile;

        rollCount = 0;
        currentEntry = "";

        if (pickRandomCsvLine(fullPath, currentEntry)) {
          rollCount = 1;
          mode = MODE_TABLE;
          tableScrollLine = 0;
        } else {
          Serial.println("No selectable lines found.");
          currentEntry = "No selectable lines.";
          rollCount = 1;
          mode = MODE_TABLE;
          tableScrollLine = 0;
        }
      }
    } else if (b == BTN_B) {
      mode = MODE_CATS;
    }
  } else if (mode == MODE_TABLE) {
    if (b == BTN_A) { // reroll
      String fullPath = String("/DATA/") + selectedCat + "/" + selectedFile;
      if (pickRandomCsvLine(fullPath, currentEntry)) {
        rollCount++;
        tableScrollLine = 0;
      }
    } else if (b == BTN_UP) {
      tableScrollLine--;
    } else if (b == BTN_DOWN) {
      tableScrollLine++;
    } else if (b == BTN_B) {
      mode = MODE_FILES;
    }
  }

  uiRedraw();
}

void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(LED_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);

  for (int i = 0; i < 4; i++) {
    pinMode(BTN_PINS[i], INPUT_PULLUP);
  }

  // OLED init
  u8g2.begin();
  u8g2.setContrast(255);

  // Boot screen
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_6x12_tf);
    u8g2.drawStr(0, 20, "Boot...");
    u8g2.drawStr(0, 40, "Init SD...");
  } while (u8g2.nextPage());

  // startup chirp
  buzzerStart(880, 40);
  delay(60);
  buzzerStart(1320, 40);

  // SD init
  Serial.println("Initializing SD...");
  while (!SD.begin(sdConfig)) {
    Serial.println("SD init failed, retrying...");
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_6x12_tf);
      u8g2.drawStr(0, 20, "Init SD...");
      u8g2.drawStr(0, 40, "SD fail, retry...");
    } while (u8g2.nextPage());
    delay(800);
  }
  Serial.println("SD init OK.");

  scanCategories();

  lastInputMs = millis();
  lastOledMs = 0;

  uiRedraw();
}

void loop() {
  uint32_t now = millis();
  buzzerUpdate(now);

  // end LED blink
  if (ledBlinkOn && (int32_t)(now - ledOffMs) >= 0) {
    analogWrite(LED_PIN, 0);
    ledBlinkOn = false;
  }

  // read buttons (edge detect)
  for (int i = 0; i < 4; i++) {
    bool curPressed = (digitalRead(BTN_PINS[i]) == LOW);

    if (!wasPressed[i] && curPressed) {
      if (now - lastPressMs[i] >= DEBOUNCE_MS) {
        lastPressMs[i] = now;
        wasPressed[i] = true;
        onButtonPressed((BtnId)i);
        Serial.print(BTN_NAMES[i]);
        Serial.println(" PRESSED");
      }
    }

    if (wasPressed[i] && !curPressed) {
      wasPressed[i] = false;
    }
  }

  // Optional periodic refresh hook (generally unnecessary with page-buffer redraw-on-input)
  if ((now - lastOledMs >= OLED_PERIOD_MS) && (now - lastInputMs >= OLED_IDLE_AFTER_MS)) {
    lastOledMs = now;
    // uiRedraw();
  }

  delay(1);
}
